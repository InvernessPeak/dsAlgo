<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>dsAlgo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Lobster&display=swap" rel="stylesheet">
    <style>



        :root {
            --wa-header-bg: #005c97; /* A deep, rich blue */
            --wa-accent-blue: #34B7F1; /* A vibrant, modern blue for accents */
            --wa-message-out-bg: #e1f6fb; /* A very light blue for sent messages */
            --wa-message-in-bg: #ffffff;
            --wa-app-bg: #f0f2f5; /* Light grey background, common in modern apps */
            --wa-chat-bg: #e5ddd5; /* Classic WhatsApp pattern background color */
            --wa-icon-color: #f0f2f5;
            --wa-text-primary: #111b21;
            --wa-text-secondary: #667781;
            --wa-border-color: #e9edef;
            --wa-active-tab-indicator: var(--wa-accent-blue);
            --wa-button-color: #008069; /* Kept a green shade for buttons for familiarity */
            --wa-link-color: #00a8e8;
            --wa-shadow: rgba(17, 27, 33, 0.15);
        }
        
        /* --- START: Dark Mode Color Palette --- */
        .dark-mode {
            --wa-header-bg: #202c33; /* Dark grey-blue */
            --wa-accent-blue: #00a884; /* WhatsApp's dark mode green */
            --wa-message-out-bg: #005c4b; /* Dark green for sent messages */
            --wa-message-in-bg: #202c33; /* Same as header */
            --wa-app-bg: #111b21; /* Very dark background */
            --wa-icon-color: #aebac1; /* Lighter grey for icons */
            --wa-text-primary: #e9edef; /* Off-white for primary text */
            --wa-text-secondary: #8696a0; /* Grey for secondary text */
            --wa-border-color: #374045; /* Dark border */
            --wa-active-tab-indicator: var(--wa-accent-blue);
            --wa-button-color: #00a884;
            --wa-link-color: #53bdeb; /* A vibrant blue for links */
            --wa-shadow: rgba(0, 0, 0, 0.2);
        }
        /* --- END: Dark Mode Color Palette --- */


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #d1d7db; /* The grey area outside the app */
        }
        
        .dark-mode body {
            background-color: #0b141a; /* Even darker outside area */
        }

        body {
            color: var(--wa-text-primary);
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Custom Scrollbar --- */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #aaa; }
        
        /* --- General UI Elements --- */
        .icon-btn {
            background: none; border: none; color: var(--wa-icon-color);
            cursor: pointer; padding: 8px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            transition: background-color 0.2s;
        }
        .icon-btn:hover { background-color: rgba(255,255,255,0.1); }
        .icon-btn svg { width: 24px; height: 24px; fill: currentColor; }

/* --- New Advanced Theme Switch Styles --- */
.header-title-cluster {
    display: flex;
    align-items: center;
    /* This line below is important to prevent the right side from shrinking */
    flex-shrink: 0; 
}
#theme-switch-container {
    position: relative;
    cursor: pointer;
    width: 140px;
    height: 34px;
    background-color: #e0e0e0;
    border-radius: 20px;
    display: flex;
    align-items: center;
    transition: background-color 0.3s ease;
    margin-left: 20px; /* Correctly spaces it from the title */
    flex-shrink: 0;
}
#theme-switch-thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 30px;
    height: 30px;
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    transition: transform 0.3s ease;
    z-index: 1;
}
#theme-switch-icon {
    position: absolute;
    top: 5px;
    left: 5px;
    width: 24px;
    height: 24px;
    transition: transform 0.3s ease;
    z-index: 2;
    color: #111b21;
}
#theme-switch-icon svg {
    width: 100%; height: 100%;
}
#theme-switch-text {
    position: absolute;
    right: 15px;
    font-size: 12px;
    font-weight: 700;
    color: #111b21;
    text-transform: uppercase;
    z-index: 2;
    transition: color 0.3s ease;
}

/* --- Styles for Dark Mode Active State --- */
.dark-mode #theme-switch-container {
    background-color: #000;
}
.dark-mode #theme-switch-thumb {
    transform: translateX(106px); /* Moves the circle to the right */
}
.dark-mode #theme-switch-icon {
    transform: translateX(106px); /* Moves the icon to the right */
    color: white;
}
.dark-mode #theme-switch-text {
    color: white;
    left: 15px; /* Moves the text to the left */
    right: auto;
}

/* --- Specific Dark Mode Overrides for "White Spaces" --- */
.dark-mode main { /* FIX for the white background space */
    background-color: var(--wa-app-bg);
}
.dark-mode .list-item-name { /* FIX for the invisible name */
    color: var(--wa-text-primary);
}

        #app-container {
            width: 100%; height: 100%; max-width: 450px; max-height: 950px;
            background-color: var(--wa-app-bg);
            box-shadow: 0 12px 28px 0 var(--wa-shadow);
            display: flex; flex-direction: column;
            overflow: hidden; position: relative;
        }

        .view {
            width: 100%; height: 100%; display: flex;
            flex-direction: column; align-items: center;
            background-color: var(--wa-message-in-bg);
        }

        /* --- Auth View --- */
        #auth-view {
            justify-content: center; padding: 40px 20px;
        }
        .app-title {
    font-family: 'Lobster', cursive; /* This applies the amazing new font */
    font-size: 60px;                 /* Increased size for more impact */
    font-weight: 400;                /* Lobster font looks best at a normal weight */
    color: var(--wa-header-bg);
    margin-bottom: 40px;
    text-align: center;
    letter-spacing: 2px;             /* Adds a little space between letters */
}
        .auth-form {
            width: 100%; max-width: 350px; display: flex;
            flex-direction: column; gap: 16px;
        }
        .auth-form input {
            border-radius: 8px; border: 1px solid #ccc; background-color: #fff;
            color: var(--wa-text-primary); padding: 14px;
            font-family: 'Roboto', sans-serif; font-size: 16px; width: 100%;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .auth-form input:focus {
            outline: none; border-color: var(--wa-header-bg);
            box-shadow: 0 0 0 2px rgba(0, 92, 151, 0.2);
        }
        .auth-form button {
            border-radius: 8px; background-color: var(--wa-header-bg);
            color: white; font-weight: 500; font-family: 'Roboto', sans-serif;
            font-size: 16px; border: none; padding: 14px; cursor: pointer;
            width: 100%; transition: background-color 0.2s;
        }
        .auth-form button:hover { background-color: #004c7a; }
        .form-switch-text {
            color: var(--wa-text-secondary); font-size: 14px; text-align: center; margin-top: 10px;
        }
        .form-switch-text a {
            color: var(--wa-link-color); text-decoration: none; cursor: pointer; font-weight: 500;
        }
        .error-message { color: #d93025; font-size: 13px; text-align: center; min-height: 20px; }
        
        /* Dark Mode: Auth View */
        .dark-mode #auth-view { background-color: var(--wa-app-bg); }
        .dark-mode .auth-form input { background-color: var(--wa-message-in-bg); border-color: var(--wa-border-color); color: var(--wa-text-primary); }


        /* --- Main View --- */
        #main-view { display: none; }
/* --- THIS IS THE NEW, SIMPLIFIED RULE TO REPLACE IT WITH --- */

/* --- THIS IS THE OLD CODE TO FIND (it might be the complex version from my last instruction) --- */

header.main-header {
    width: 100%;
    background-color: var(--wa-header-bg);
    flex-shrink: 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    z-index: 5;

    /* (Potentially complex padding rules are here) */
    padding: 10px 15px 0;
    padding-top: calc(10px + env(safe-area-inset-top));
    padding-right: calc(15px + env(safe-area-inset-right));
    padding-left: calc(10px + env(safe-area-inset-left));
}


        .header-top { display: flex; justify-content: space-between; align-items: center; }
        .header-title {
            font-size: 20px; 
            font-family: 'Lobster', cursive; 
            font-weight: 500; 
            color: var(--wa-icon-color);
            letter-spacing: 1px;             /* A little spacing for style */
            line-height: 1; 
        }
        .header-actions { display: flex; gap: 10px; }
        #search-input {
    flex-grow: 1;
    background-color: transparent;
    border: none;
    outline: none;
    color: var(--wa-icon-color);
    font-size: 16px;
    padding: 8px;
    margin-left: 10px;
}
#search-input::placeholder {
    color: rgba(240, 242, 245, 0.6);
}
.dark-mode #search-input::placeholder {
    color: var(--wa-text-secondary);
}

        .header-nav { display: flex; justify-content: space-around; margin-top: 15px; }
        .nav-tab {
            background: none; border: none; color: rgba(255, 255, 255, 0.7);
            font-family: 'Roboto', sans-serif; font-size: 14px; font-weight: 700;
            cursor: pointer; padding: 12px 16px; flex-grow: 1;
            border-bottom: 3px solid transparent; transition: color 0.2s, border-color 0.2s;
            position: relative; text-transform: uppercase;
        }
        .dark-mode .nav-tab { color: var(--wa-text-secondary); }
        .nav-tab.active {
            color: var(--wa-active-tab-indicator);
            border-bottom-color: var(--wa-active-tab-indicator);
        }
        .badge {
            position: absolute; top: 8px; right: 15%;
            background-color: var(--wa-active-tab-indicator);
            color: white; border-radius: 10px; font-size: 11px;
            padding: 2px 6px; font-weight: 500;
            display: none;
        }
        .dark-mode .badge { color: #111b21; }
        main {
            width: 100%; flex-grow: 1; overflow-y: auto; background-color: #fff;
        }
        .content-panel { display: none; }
        .content-panel.active { display: block; }

        .list-item {
            display: flex; align-items: center; padding: 10px 15px;
            cursor: pointer; background-color: #fff;
            border-bottom: 1px solid var(--wa-border-color);
            transition: background-color 0.2s;
        }
        .dark-mode .list-item { background-color: var(--wa-app-bg); }
        .list-item:hover { background-color: var(--wa-app-bg); }
        .dark-mode .list-item:hover { background-color: var(--wa-header-bg); }
        .list-item:last-child { border-bottom: none; }
        .list-item-emoji {
            font-size: 24px; margin-right: 15px; width: 48px; height: 48px;
            display: flex; align-items: center; justify-content: center;
            background-color: #ccc; border-radius: 50%;
        }



.list-item-details {
    flex-grow: 1;
    position: relative; /* Needed to position the dot */
}

/* --- New Presence Status Dot Styles --- */
.status-dot {
    position: absolute;
    top: 6px;
    right: 0;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.3s ease;
}
/* This rule adds the "cutout" effect in LIGHT mode */
#contact-list .status-dot {
    border: 2px solid #fff;
}
/* This rule adds the "cutout" effect in DARK mode */
.dark-mode #contact-list .status-dot {
    border: 2px solid var(--wa-app-bg);
}
.status-dot.online {
    background-color: #25d366; /* Bright green */
}
.status-dot.offline {
    background-color: #667781; /* Grey */
}

/* Positioning for the dot and text inside the chat header */
#chat-header-info {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}
#chat-header-status {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--wa-icon-color);
    opacity: 0.8;
}
.dark-mode #chat-header-status { color: var(--wa-text-secondary); }

#chat-header-status .status-dot {
    position: static; /* Override the absolute positioning */
    width: 8px;
    height: 8px;
    border: none; /* No border needed in the header */
}

        .list-item-name { font-weight: 500; font-size: 17px; margin-bottom: 2px; }
        .list-item-subtext {
            font-size: 14px; color: var(--wa-text-secondary);
        }
        .list-item-actions { display: flex; gap: 10px; }
        .list-item-actions button {
            background-color: var(--wa-accent-blue);
            color: white; border: none; padding: 8px 12px; border-radius: 8px;
            cursor: pointer; font-size: 13px; font-weight: 500;
        }
        .dark-mode .list-item-actions button { color: var(--wa-text-primary); }
        .list-item-actions button.reject { background-color: var(--wa-text-secondary); }

/* --- Chat View --- */
#chat-view {
    display: none; position: absolute;
    top: 0; left: 0; z-index: 10;
    /* --- START: New Sky Gradient Day Mode Background --- */
    background-color: #a7d7f9; /* A pleasant blue fallback color */
    background-image: linear-gradient(to bottom, #87CEEB, #dff1f9); /* Sky blue to light blue gradient */
    /* --- END: New Sky Gradient Day Mode Background --- */
}
/* Dark Mode: Chat background */
.dark-mode #chat-view {
    background-color: #0b141a;
    background-image: none; /* Or a subtle dark pattern */
}


        header.chat-header {
            width: 100%; padding: 8px 10px; display: flex; align-items: center;
            gap: 10px; background-color: var(--wa-header-bg);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; z-index: 1;
        }
        header.chat-header .icon-btn { color: var(--wa-icon-color); }
        #chat-header-info { text-align: left; flex-grow:1; color: var(--wa-icon-color); }
        #chat-header-emoji { width:40px; height: 40px; font-size: 22px; background-color: #ccc; }
        #chat-header-name { font-weight: 500; font-size: 17px; }
        .dark-mode #chat-header-name { color: var(--wa-text-primary); }
        .chat-header-actions { display:flex; align-items: center; gap: 5px; }

        #chat-messages {
            flex-grow: 1; width: 100%; padding: 12px; overflow-y: auto;
            display: flex; flex-direction: column; gap: 3px;
        }
        
        .message-bubble {
            max-width: 80%; 
            padding: 8px 12px; 
            border-radius: 8px;
            margin-bottom: 2px; 
            word-wrap: break-word; 
            line-height: 1.4;
            box-shadow: 0 1px 1px var(--wa-shadow);
            position: relative;
            min-width: 100px;
        }

        .message-meta {
    position: absolute;
    bottom: 5px;
    right: 8px;
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--wa-text-secondary);
}
/* By default, bubbles have more padding to make space for the meta info */
.message-bubble {
    padding-bottom: 25px;
}
.message-meta .ticks svg {
    width: 16px;
    height: 16px;
    fill: currentColor;
}
.dark-mode .message-meta {
    color: #8696a0; /* A slightly lighter grey for dark mode */
}
.ticks.blue-ticks {
    color: #53bdeb; /* The iconic blue tick color */
}

.message-sent {
    background-color: #e1f6fb;
    color: #111b21;
    align-self: flex-end;
    border-bottom-right-radius: 0;
}
.dark-mode .message-sent {
    background-color: var(--wa-message-out-bg);
    color: var(--wa-text-primary);
}

.message-received {
    background-color: #ffffff;
    color: #111b21;
    align-self: flex-start;
    border-bottom-left-radius: 0;
}
.dark-mode .message-received {
    background-color: var(--wa-message-in-bg);
    color: var(--wa-text-primary);
}


        
        #chat-input-container {
            width: 100%; padding: 8px 12px; display: flex; gap: 10px;
            background-color: var(--wa-app-bg); align-items: flex-end;
        }
        #chat-input {
            flex-grow: 1; border: none; background-color: #fff;
            color: var(--wa-text-primary); padding: 12px 18px;
            border-radius: 22px; font-family: 'Roboto', sans-serif;
            font-size: 15px; max-height: 100px; resize: none;
        }
        .dark-mode #chat-input {
            background-color: var(--wa-message-in-bg);
            color: var(--wa-text-primary);
        }
        #chat-input:focus { outline: none; }
        #chat-send-btn {
            background: var(--wa-accent-blue); border: none; color: white;
            width: 44px; height: 44px; border-radius: 50%; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0; margin-bottom: 2px;
            transition: background-color 0.2s;
        }
        #chat-send-btn:hover { background-color: #2aa3e0; }
        .dark-mode #chat-send-btn:hover { background-color: #008a6b; }
        #chat-send-btn svg { width: 24px; height: 24px; fill: white; margin-left: 2px; }

        /* --- Call Views --- */
        .call-view {
            display: none; position: absolute; top: 0; left: 0; z-index: 20;
            background-color: #222; justify-content: center; align-items: center;
        }
        #video-call-view { background-color: black; }
        #remote-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2; /* This is the critical fix */
}
        
        #local-video {
            width: 100px; height: 140px; position: absolute; bottom: 120px; right: 20px;
            border: 2px solid rgba(255,255,255,0.5); border-radius: 10px;
            cursor: move; object-fit: cover; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .call-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            align-items: center; padding: 60px 20px 50px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent 40%, transparent 60%, rgba(0,0,0,0.7));
        }
        .caller-info { text-align: center; color: white; text-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .caller-info .emoji { font-size: 80px; }
        .caller-info .name { font-size: 28px; font-weight: 500; margin-top: 10px; }
        .caller-info .status { font-size: 16px; color: #ccc; margin-top: 5px; }
        .call-controls { display: flex; gap: 30px; }
        .call-controls button {
            width: 70px; height: 70px; border-radius: 50%; border: none;
            color: white; font-family: 'Roboto', sans-serif; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .end-call-btn { background-color: #e91e63; }
        .accept-call-btn { background-color: #4CAF50; }

        /* --- Modals --- */
        .modal {
            display: none; position: absolute; top: 0; left: 0; width: 100%;
            height: 100%; background-color: rgba(0, 0, 0, 0.5);
            justify-content: center; align-items: center; z-index: 30;
        }
        .modal-content {
            background-color: #fff; padding: 25px; border-radius: 12px;
            width: 90%; max-width: 400px; display: flex; flex-direction: column;
            gap: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .dark-mode .modal-content {
            background-color: var(--wa-message-in-bg);
        }

        .modal-content h2 { text-align: center; color: var(--wa-header-bg); font-weight: 500; }
        .dark-mode .modal-content h2 {color: #FFFFFF;}

        .modal-content input {
            border-radius: 8px; border: 1px solid #ccc; background-color: var(--wa-app-bg);
            color: var(--wa-text-primary); padding: 12px 15px; font-family: 'Roboto', sans-serif;
            font-size: 16px; width: 100%;
        }
        .dark-mode .modal-content input {
            border-color: var(--wa-border-color);
            background-color: var(--wa-app-bg);
        }
        .modal-content button {
            border-radius: 8px; background-color: var(--wa-header-bg);
            color: white; font-weight: 500; font-family: 'Roboto', sans-serif;
            font-size: 16px; border: none; padding: 12px 20px; cursor: pointer; width: 100%;
        }
        .dark-mode .modal-content button {
            color: var(--wa-text-primary);
        }
        .modal-content button.secondary { background-color: var(--wa-text-secondary); }
        .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px; }
        #incoming-call-modal .caller-info { color: var(--wa-text-primary); text-shadow: none; padding-bottom: 20px; }
        #profile-info-display p { padding: 5px 0; font-size: 16px; }
        #profile-info-display strong { color: var(--wa-header-bg); font-weight: 500; }
        #blocked-users-list .list-item { background-color: transparent; }
        #blocked-users-list .list-item-actions button {
            background-color: var(--wa-accent-blue); font-size: 12px; padding: 6px 10px;
        }



        /* --- Profile Picture Styles --- */
        .pfp-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 15px;
        }
        .profile-picture {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        .dark-mode .profile-picture { border-color: var(--wa-message-in-bg); }
        .profile-emoji-display {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
        }
        .pfp-upload-label {
            display: block;
            text-align: center;
            padding: 10px;
            background-color: var(--wa-app-bg);
            border: 1px dashed #ccc;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 14px;
            color: var(--wa-text-secondary);
        }
        .pfp-upload-label:hover {
            background-color: var(--wa-border-color);
        }
        .dark-mode .pfp-upload-label { border-color: var(--wa-border-color); }

        /* Generic class for all circular profile pictures in lists/headers */
        .list-item-pfp {
            font-size: 24px;
            margin-right: 15px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #ccc;
            border-radius: 50%;
            flex-shrink: 0;
            overflow: hidden; /* Important for circular images */
        }
        .list-item-pfp img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }


.copy-btn {
    background: none;
    border: 1px solid transparent;
    /* ... and the rest of the rules for .copy-btn, :hover, and .copied ... */
}
.copy-btn.copied {
    background-color: #15d30b;
    color: var(--wa-button-color); /* Green color */
    border-color: var(--wa-button-color);
}



/* --- New Styles for Blurry Call Background --- */
        .call-view {
            background-color: #2c3e50; /* A dark slate blue fallback */
        }
        .call-background {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            z-index: 1;
        }
        .call-background img {
            width: 100%; height: 100%;
            object-fit: cover;
            filter: blur(20px) brightness(0.7); /* Blur effect and darkening */
            transform: scale(1.1); /* Prevents hard edges from the blur */
        }
        .call-overlay {
            z-index: 3; /* Ensure overlay is on top of the background */
        }
        .caller-info .emoji {
            width: 120px;   /* Give the overlay PFP a fixed size */
            height: 120px;
            font-size: 60px;
            margin: 0 auto;
            border-radius: 50%;
            background-color: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* For the image */
        }
        .caller-info .emoji img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* --- CSS Fix for Incoming Call Modal PFP --- */
#incoming-caller-info .profile-emoji-display {
    width: 120px;           /* A good size for the preview */
    height: 120px;
    font-size: 60px;          /* Make emoji larger if no picture */
    margin: 0 auto 15px;    /* Center it and add space below */
    border-radius: 50%;     /* This makes the container circular */
    overflow: hidden;         /* This clips the image to the circular shape */
    border: 4px solid #fff; /* Adds a nice white border */
    box-shadow: 0 5px 15px rgba(0,0,0,0.2); /* Adds some depth */
    background-color: #ccc;   /* Fallback color */
}
.dark-mode #incoming-caller-info .profile-emoji-display {
    border-color: var(--wa-message-in-bg);
}
/* This is the new, essential rule that fixes the zoom issue */
#incoming-caller-info .profile-emoji-display img {
    width: 100%;
    height: 100%;
    object-fit: cover;      /* Scales the image to cover the circle without distortion */
}






/* --- START: Fixes for Dark Mode Visibility --- */

/* Fixes invisible "Name:" and "ID:" text in the profile modal */
.dark-mode #profile-info-display strong {
    color: var(--wa-text-secondary); /* Uses a visible grey color */
}

/* Fixes the layout and visibility of the user's name in the profile */
#profile-details-display .profile-name {
    font-size: 20px;
    font-weight: 500;
    margin-bottom: 8px;
}

/* Fixes the layout for the ID and Copy button container */
#profile-details-display .profile-id-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px; /* Adds space between the ID and the copy button */
}

/* General style for link-like text buttons in dark mode modals */
.dark-mode .modal-actions button:not(.secondary) {
    background-color: transparent;
    color: var(--wa-link-color); /* Makes text a vibrant, visible blue */
    font-weight: 700;
}

/* Fixes the invisible "Edit" button in the profile modal */
/* --- THIS IS THE NEW CODE TO REPLACE IT WITH --- */

/* Styles the "Edit" button with a green background and white text */
#edit-profile-btn {
    background-color: #25D366; /* Light green background */
    color: #FFFFFF;             /* White text */
    border: none;
    cursor: pointer;
    font-size: 16px;
    font-weight: 500;
    padding: 10px 20px;         /* Added padding for button shape */
    border-radius: 8px;         /* Rounded corners */
    width: auto;                /* Ensure it doesn't stretch full-width */
    margin: 0 auto;             /* Center the button */
    display: block;             /* Needed for margin auto to work */
}

/* Fixes the invisible "COPY" button and ensures it's styled correctly */
#copy-id-btn {
    background-color: #00a884; /* Keeps the unique blue color */
    color: #FFFFFF;
    border: none;
    cursor: pointer;
    padding: 10px 20px;         /* <-- Matched from Edit button */
    border-radius: 8px;         /* <-- Matched from Edit button */
    font-size: 16px;            /* <-- Matched from Edit button */
    font-weight: 500;           /* <-- Matched from Edit button */
    transition: background-color 0.2s, color 0.2s;
}

/* Style for the "COPIED!" state in BOTH modes */
#copy-id-btn.copied {
    background-color: #22c4ff; /* A different, bright green for feedback */
    color: #FFFFFF;            /* White text */
    border: none;
}

/* --- END: Fixes for Dark Mode Visibility --- */

.dark-mode .app-title {
    color: var(--wa-text-primary); /* Overrides the color to be the theme's primary (light) text color */
}


/* --- THIS IS THE NEW CODE TO ADD --- */

/* Makes the message bubble a positioning container for the menu */
.message-bubble {
    position: relative;
}

/* Styles for the pop-up context menu */
.message-context-menu {
    position: absolute;
    bottom: 100%; /* Position it right above the message bubble */
    margin-bottom: 6px; /* A little space between the menu and the message */
    display: flex;
    gap: 8px;
    background-color: #ffffff;
    padding: 8px;
    border-radius: 18px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    z-index: 40; /* Ensure it appears above other elements */
    transition: transform 0.1s ease-out, opacity 0.1s ease-out;
    opacity: 0;
    transform: scale(0.95);
    animation: fadeInMenu 0.1s forwards; /* A subtle animation */
}

/* --- ADD THIS NEW RULE DIRECTLY BELOW IT --- */
.message-context-menu.menu-below {
    bottom: auto; /* Unset the default 'above' positioning */
    top: 100%;    /* Position it below the message bubble */
    margin-bottom: 0; /* Remove the old margin */
    margin-top: 6px;  /* Add a new margin for the space below */
}

/* Align the menu for messages sent by the user */
.message-sent .message-context-menu {
    right: 0;
}

/* Align the menu for messages received from others */
.message-received .message-context-menu {
    left: 0;
}

/* Styles for dark mode menu */
.dark-mode .message-context-menu {
    background-color: #202c33; /* Dark background for the menu */
}

/* Styles for the buttons inside the menu */
.context-menu-btn {
    background: none;
    border: none;
    color: var(--wa-text-secondary);
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    padding: 6px 10px;
}
.dark-mode .context-menu-btn {
    color: var(--wa-text-primary);
}
.context-menu-btn:hover {
    color: var(--wa-link-color);
}

/* Keyframe animation for the menu appearing */
@keyframes fadeInMenu {
    to {
        opacity: 1;
        transform: scale(1);
    }
}



/* --- THIS IS THE NEW CODE TO ADD --- */

/* --- Splash Screen Styles --- */
#splash-screen {
    background-color: #005c97; /* Consistent rich blue for both modes */
    justify-content: center;
    align-items: center;
    z-index: 100; /* Ensure it's on top of all other views */
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
}

/* This class will be added by JavaScript to hide the splash screen */
#splash-screen.hidden {
    opacity: 0;
    visibility: hidden;
}

.splash-title {
    font-family: 'Lobster', cursive; /* The amazing font from the login page */
    font-size: 72px;
    color: #FFFFFF;
    font-weight: 400;
    letter-spacing: 2px;
    /* A subtle animation to make it feel alive while loading */
    animation: pulse 2s infinite ease-in-out;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

          /* --- THIS IS THE NEW CODE TO ADD --- */

/* --- PFP Viewer Modal Styles --- */
.pfp-viewer {
    display: none; /* Hidden by default */
    position: fixed; /* Stays in place even if the page scrolls */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85); /* Dark, semi-transparent background */
    z-index: 100;
    justify-content: center;
    align-items: center;
}

#close-pfp-viewer {
    position: absolute;
    top: calc(15px + env(safe-area-inset-top)); /* Respects phone status bars */
    right: 15px;
    z-index: 102;
    background-color: rgba(0,0,0,0.3);
}
#close-pfp-viewer:hover {
    background-color: rgba(0,0,0,0.6);
}

/* --- THIS IS THE NEW, CIRCULAR STYLE CODE TO REPLACE IT WITH --- */

#pfp-viewer-content {
    /* Define a size for the circular frame. This is responsive. */
    width: 90vw;
    height: 90vw; /* Enforces a square aspect ratio */
    max-width: 400px; /* Sets a maximum size for larger screens like tablets */
    max-height: 400px;
    border-radius: 50%; /* This is the key to making it a circle */
    overflow: hidden;   /* This clips the image to the circular shape */
    position: relative;
    border: 3px solid rgba(255, 255, 255, 0.5); /* Adds a subtle, elegant border */
    box-shadow: 0 5px 25px rgba(0,0,0,0.5);   /* Adds some depth */
}

#pfp-viewer-image {
    /* The image will now fill the circular container perfectly */
    width: 100%;
    height: 100%;
    object-fit: cover; /* Scales the image to fill the circle without distortion */
    cursor: grab;
    transition: transform 0.1s ease-out;
    transform: scale(1) translate(0, 0);
    /* The border-radius is no longer needed here */
}


#pfp-viewer-image.panning {
    cursor: grabbing; /* Indicates the image is currently being moved */
}

/* --- THIS IS THE NEW CODE TO ADD --- */

/* --- Click-to-Copy Styles --- */
/* Makes the name in the chat header look clickable */
#chat-header-name {
    cursor: pointer;
    transition: opacity 0.2s ease;
}
#chat-header-name:hover {
    opacity: 0.8;
}

/* This class provides the "Copied!" visual feedback */
#chat-header-name.copied-feedback {
    color: #25D366 !important; /* A bright green for success feedback */
    font-weight: 700;
}
/* In dark mode, use the theme's bright accent green */
.dark-mode #chat-header-name.copied-feedback {
    color: var(--wa-accent-blue) !important;
}

    </style>
 </head>
<body>

    <div id="app-container">
        
    <!-- ADD THIS NEW BLOCK OF CODE RIGHT HERE -->
    <!-- Splash Screen -->
    <div id="splash-screen" class="view">
        <h1 class="splash-title">dsAlgo</h1>
    </div>

    <!-- Auth View -->
    <div id="auth-view" class="view" style="display: none;">
        <!-- ... the rest of your auth-view content ... -->
            <h1 class="app-title">dsAlgo</h1>
            <form id="login-form" class="auth-form">
                <div id="login-error" class="error-message"></div>
                <input type="text" id="login-identifier" placeholder="Email or dsAlgo ID" required>
                <input type="password" id="login-password" placeholder="Password" required>
                <button type="submit">Log In</button>
                <p class="form-switch-text">Don't have an account? <a id="show-signup">Sign up</a></p>
            </form>
            <form id="signup-form" class="auth-form" style="display: none;">
                <div id="signup-error" class="error-message"></div>
                <input type="email" id="signup-email" placeholder="Email" required>
                <input type="password" id="signup-password" placeholder="Password" required>
                <button type="submit">Sign Up</button>
                <p class="form-switch-text">Already have an account? <a id="show-login">Log in</a></p>
            </form>
        </div>

        <!-- Main App View -->

<div id="main-view" class="view">


<header class="main-header">


<div class="header-top">
    <!-- START: New Title Cluster for correct positioning -->
    <div class="header-title-cluster">
        <span class="header-title">dsAlgo</span>
        <div id="theme-switch-container" title="Toggle Theme">
            <div id="theme-switch-thumb"></div>
            <div id="theme-switch-icon"></div>
            <span id="theme-switch-text"></span>
        </div>
    </div>
    <!-- END: New Title Cluster -->

    <div class="header-actions">
    <!-- START: New Search Button -->
    <button id="search-btn" class="icon-btn" title="Search">
        <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path></svg>
    </button>
    <!-- END: New Search Button -->

    <button id="add-friend-btn" class="icon-btn" title="Add Friend">
        <svg viewBox="0 0 24 24"><path d="M15 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm-9-2V7H4v3H1v2h3v3h2v-3h3v-2H6zm9 4c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"></path></svg>
    </button>
    <button id="menu-btn" class="icon-btn" title="Profile & Settings">
        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"></path></svg>
    </button>
</div>
</div>

                <nav class="header-nav">
                    <button id="nav-home" class="nav-tab active">Chats <span id="home-badge" class="badge"></span></button>
                    <button id="nav-notifications" class="nav-tab">Updates <span id="notifications-badge" class="badge"></span></button>
                    <button id="nav-calls" class="nav-tab">Calls</button>
                </nav>
            


</header> <!-- This is the closing tag of your existing main-header -->

<!-- START: New Search Header -->
<header id="search-header" class="main-header" style="display: none; padding-bottom: 10px;">
    <div class="header-top">
        <button id="close-search-btn" class="icon-btn" title="Close Search">
            <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></svg>
        </button>
        <input type="text" id="search-input" placeholder="Search...">
    </div>
</header>
<!-- END: New Search Header -->


            <main id="main-content">
                <div id="home-content" class="content-panel active"><div id="contact-list"></div></div>
                <div id="notifications-content" class="content-panel"><div id="notification-list"></div></div>
                <div id="calls-content" class="content-panel"><div id="call-log-list"></div></div>
            </main>
        </div>
        
        <!-- Chat View -->
        <div id="chat-view" class="view">
            <header class="chat-header">
                <button id="back-to-main-btn" class="icon-btn">
                     <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></svg>
                </button>
                <!-- <div id="chat-header-emoji" class="list-item-emoji"></div> -->

                <div id="chat-header-pfp" class="list-item-pfp"></div>
                
                <div id="chat-header-info">
    <span id="chat-header-name"></span>
    <!-- START: New Status Display -->
    <div id="chat-header-status">
        <div class="status-dot offline"></div>
        <span id="chat-header-status-text">Offline</span>
    </div>
    <!-- END: New Status Display -->
</div>

                <div class="chat-header-actions">
                  <button id="voice-call-btn" class="icon-btn" title="Voice Call">
                    <svg viewBox="0 0 24 24"><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"></path></svg>
                  </button>
                  <button id="video-call-btn" class="icon-btn" title="Video Call">
                    <svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"></path></svg>
                  </button>
                  <button id="chat-more-btn" class="icon-btn" title="More options">
                    <svg viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                  </button>
                </div>
            </header>
            <div id="chat-messages"></div>
            <div id="chat-input-container">
                <input type="text" id="chat-input" placeholder="Message">
                <button id="chat-send-btn">
                    <svg viewBox="0 0 24 24" fill="white"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                </button>
            </div>
        </div>
        
        <!-- Call Views -->
        <div id="video-call-view" class="view call-view">
             <div class="call-background"><img src="" alt="Caller background"></div>
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>
            <div class="call-overlay">
                <div id="video-caller-info" class="caller-info"><div class="emoji"></div><div class="name"></div><div class="status"></div></div>
                <div class="call-controls">
                    <button id="end-video-call-btn" class="end-call-btn">
                        <svg fill="white" viewBox="0 0 24 24" width="36" height="36">
    <path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56a.97.97 0 00-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-.99v-3.45c0-.54-.45-.98-.99-.98z" transform="rotate(135 12 12)"></path>
</svg>


                    </button>
                </div>
            </div>
        </div>
        <div id="voice-call-view" class="view call-view">
            <div class="call-background"><img src="" alt="Caller background"></div>
            <audio id="remote-audio" autoplay playsinline></audio>
            <div class="call-overlay">
                <div id="voice-caller-info" class="caller-info"><div class="emoji"></div><div class="name"></div><div class="status"></div></div>
                <div class="call-controls">
                    <button id="end-voice-call-btn" class="end-call-btn">
                        <!-- THIS IS THE NEW, CLEAN SVG CODE TO REPLACE IT WITH -->

                      <svg fill="white" viewBox="0 0 24 24" width="36" height="36">
                          <path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56a.97.97 0 00-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-.99v-3.45c0-.54-.45-.98-.99-.98z" transform="rotate(135 12 12)"></path>
                      </svg>


                    </button>
                </div>
            </div>
        </div>

        <!-- Modals -->
        <div id="profile-setup-modal" class="modal"><div class="modal-content"><h2>Set up your Profile</h2><input type="text" id="profile-name-input" placeholder="Your Name" required><input type="text" id="profile-emoji-input" placeholder="Emoji (e.g., ðŸ˜Š)" maxlength="2" required><button id="save-profile-btn">Save Profile</button></div></div>
        <div id="add-friend-modal" class="modal"><div class="modal-content"><h2>Add Friend</h2><p>Enter your friend's dsAlgo ID (e.g., jg-1234)</p><input type="text" id="add-friend-id-input" placeholder="jg-xxxx"><div class="modal-actions"><button id="close-add-friend-modal-btn" class="secondary">Cancel</button><button id="send-friend-request-btn">Send Request</button></div></div></div>
        
        
        <div id="profile-view-modal" class="modal">
    <div class="modal-content">
        <h2>Profile</h2>

        <!-- Profile Picture and Info Display -->
        <div id="profile-info-display">
             <div class="pfp-container">
                <img id="profile-pfp-display" class="profile-picture" src="" alt="Profile Picture" style="display:none;">
                <div id="profile-emoji-display" class="profile-emoji-display"></div>
             </div>
             <div id="profile-details-display" style="text-align:center;"></div>
        </div>

        <!-- Profile Editing Form -->
        <div id="profile-edit-form" style="display:none;">
            <input type="text" id="edit-profile-name" placeholder="Your Name">
            <input type="text" id="edit-profile-emoji" placeholder="Emoji" maxlength="2">
            <label for="pfp-upload-input" class="pfp-upload-label">Change Profile Picture</label>
            <input type="file" id="pfp-upload-input" accept="image/*" style="display:none;">
            <button id="remove-pfp-btn" class="secondary" style="width:100%; margin-top: 10px;">Remove Picture</button>
        </div>

        <div class="modal-actions">
            <button id="edit-profile-btn">Edit</button>
            <button id="save-profile-changes-btn" style="display:none;">Save</button>
        </div>
        <div id="blocked-users-section">
            <h3>Blocked Users</h3>
            <div id="blocked-users-list" style="max-height: 120px; overflow-y: auto;"></div>
        </div>
        <button id="logout-btn" style="margin-top: 15px; background-color: #d93025;">Logout</button>
        <button id="close-profile-modal-btn" class="secondary">Close</button>
    </div>
</div>
        
        
        <div id="incoming-call-modal" class="modal"><div class="modal-content"><h2>Incoming Call</h2><div id="incoming-caller-info" class="caller-info"><div class="profile-emoji-display"></div><div class="name"></div></div><div class="modal-actions" style="justify-content:space-around; padding: 10px 0;"><button id="reject-call-btn" class="end-call-btn">Reject</button><button id="accept-call-btn" class="accept-call-btn">Accept</button></div></div></div>
    </div>
    
    <audio id="ringtone" loop><source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" type="audio/wav"></audio>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <script>
        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
  apiKey: "AIzaSyChBnEuAXyJm16yZq3iNvPLb8F2fKKPyuw",
  authDomain: "dsalgo-video-calling-app.firebaseapp.com",
  databaseURL: "https://dsalgo-video-calling-app-default-rtdb.firebaseio.com",
  projectId: "dsalgo-video-calling-app",
  storageBucket: "dsalgo-video-calling-app.firebasestorage.app",
  messagingSenderId: "391463077849",
  appId: "1:391463077849:web:b0800f2b5989f9fab83bc8"
};
        
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();

        // --- GLOBAL STATE ---
        let currentUser = null, currentChatPartner = null, currentCallData = null;
        let peerConnection, localStream, remoteStream;
        let longPressTimer; 
        const stunServers = { iceServers: [ { urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' } ] };
        
        // --- UI ELEMENT SELECTORS ---
        const allViews = document.querySelectorAll('.view');
        const allContentPanels = document.querySelectorAll('.content-panel');
        const ringtone = document.getElementById('ringtone');

        // --- UTILITY FUNCTIONS ---

        const createUserPfp = (user, elementClass) => {
    if (user.photoURL) {
        return `<div class="${elementClass}"><img src="${user.photoURL}" alt="${user.name}"></div>`;
    } else {
        return `<div class="${elementClass}">${user.emoji || 'ðŸ‘¤'}</div>`;
    }
};
        const showView = (viewId) => {
            allViews.forEach(v => v.style.display = 'none');
            document.getElementById(viewId).style.display = 'flex';
        };
        const showModal = (modalId, show = true) => { document.getElementById(modalId).style.display = show ? 'flex' : 'none'; };
        const showPanel = (panelId) => {
            allContentPanels.forEach(p => p.classList.remove('active'));
            document.getElementById(panelId).classList.add('active');
            document.querySelectorAll('.nav-tab').forEach(b => b.classList.remove('active'));
            if(panelId === 'home-content') document.getElementById('nav-home').classList.add('active');
            if(panelId === 'notifications-content') document.getElementById('nav-notifications').classList.add('active');
            if(panelId === 'calls-content') document.getElementById('nav-calls').classList.add('active');
        };
        const generateJgId = () => `jg-${Math.floor(1000 + Math.random() * 9000)}`;
        const getChatId = (uid1, uid2) => [uid1, uid2].sort().join('_');

        // --- AUTHENTICATION ---
        // --- REPLACE YOUR ENTIRE OLD auth.onAuthStateChanged FUNCTION WITH THIS NEW ONE ---

auth.onAuthStateChanged(async (user) => {
    // We add a minimum 1.5-second delay. This ensures the splash screen is
    // visible for a good amount of time, preventing a jarring flash on fast connections.
    setTimeout(() => {
        if (user) {
            // If a user is found, check if their profile is set up in the database.
            db.ref(`users/${user.uid}`).once('value', (snapshot) => {
                if (snapshot.exists()) {
                    // --- User is logged in AND has a profile ---
                    const wasNull = currentUser === null;
                    currentUser = { uid: user.uid, ...snapshot.val() };
                    if (wasNull) initializeApp(); // Initialize listeners only once
                    showView('main-view'); // Show the main chat screen
                    hideSplashScreen();    // Fade out the splash screen
                } else {
                    // --- User is logged in BUT profile is not set up ---
                    showView('auth-view'); // Show auth view in the background
                    showModal('profile-setup-modal'); // Show the setup modal over it
                    hideSplashScreen(); // Fade out the splash screen
                }
            });
        } else {
            // --- No user is logged in ---
            currentUser = null;
            showView('auth-view'); // Show the login/signup page
            hideSplashScreen();    // Fade out the splash screen
        }
    }, 1500); // 1.5 second minimum splash screen time
});
        
        //document.getElementById('login-form').addEventListener('submit', (e) => { e.preventDefault(); auth.signInWithEmailAndPassword(document.getElementById('login-email').value, document.getElementById('login-password').value).catch(error => document.getElementById('login-error').textContent = error.message); });
        // --- REPLACE YOUR ENTIRE OLD 'login-form' EVENT LISTENER WITH THIS NEW ONE ---

document.getElementById('login-form').addEventListener('submit', (e) => {
    e.preventDefault();
    const identifier = document.getElementById('login-identifier').value.trim();
    const password = document.getElementById('login-password').value;
    const loginError = document.getElementById('login-error');
    loginError.textContent = ''; // Clear previous errors

    if (!identifier || !password) {
        loginError.textContent = 'Both fields are required.';
        return;
    }

    // This function handles the actual Firebase login to avoid repeating code.
    const performLogin = (email, pass) => {
        auth.signInWithEmailAndPassword(email, pass)
            .catch(error => {
                // Catches errors like wrong password.
                loginError.textContent = error.message;
            });
    };

    // Check if the identifier looks like an email.
    if (identifier.includes('@')) {
        // --- Login with Email ---
        performLogin(identifier, password);
    } else {
        // --- Login with dsAlgo ID ---
        // Query the database to find the user with the matching jgId.
        db.ref('users').orderByChild('jgId').equalTo(identifier).once('value', snapshot => {
            if (snapshot.exists()) {
                // The dsAlgo ID was found.
                const userData = snapshot.val();
                // Extract the user's unique key and their email from the result.
                const userKey = Object.keys(userData)[0];
                const userEmail = userData[userKey].email;

                if (userEmail) {
                    // We found the email, now we can attempt to log in.
                    performLogin(userEmail, password);
                } else {
                    // This is an edge case in case the user's data is corrupted.
                    loginError.textContent = 'User data is incomplete. Cannot log in.';
                }
            } else {
                // The dsAlgo ID was not found in the database.
                loginError.textContent = 'No user found with that dsAlgo ID.';
            }
        }).catch(dbError => {
            // Handle potential database query errors.
            loginError.textContent = 'An error occurred. Please try again.';
            console.error("Database query error: ", dbError);
        });
    }
});

        document.getElementById('signup-form').addEventListener('submit', (e) => {
            e.preventDefault();
            auth.createUserWithEmailAndPassword(document.getElementById('signup-email').value, document.getElementById('signup-password').value)
                .then(userCredential => { currentUser = { uid: userCredential.user.uid, email: userCredential.user.email }; showModal('profile-setup-modal'); })
                .catch(error => document.getElementById('signup-error').textContent = error.message);
        });
        document.getElementById('logout-btn').addEventListener('click', () => { auth.signOut(); showModal('profile-view-modal', false); });
        document.getElementById('show-signup').addEventListener('click', () => { document.getElementById('login-form').style.display = 'none'; document.getElementById('signup-form').style.display = 'flex'; });
        document.getElementById('show-login').addEventListener('click', () => { document.getElementById('signup-form').style.display = 'none'; document.getElementById('login-form').style.display = 'flex'; });

        // --- PROFILE MANAGEMENT ---
        document.getElementById('save-profile-btn').addEventListener('click', () => {
            const name = document.getElementById('profile-name-input').value.trim();
            const emoji = document.getElementById('profile-emoji-input').value.trim();
            if (!name || !emoji) return alert('Name and Emoji are required.');
            const jgId = generateJgId();
            const profileData = { name, emoji, jgId, email: currentUser.email, contacts: {}, blocked: {} };
            db.ref(`users/${currentUser.uid}`).set(profileData).then(() => showModal('profile-setup-modal', false));
        });
        
function initializeApp() { 
    listenAndRenderContacts();
    listenForFriendRequests(); 
    listenForIncomingCalls(); 
    listenForUnreadMessages(); 
    renderCallLogs();
    runDeliveryAgent();///
    manageUserPresence();
    history.pushState({ page: 'home' }, 'Home', '#home');

    // Listen for the 'popstate' event, which fires when the user clicks the back button.
    window.addEventListener('popstate', (event) => {
        // Run our master back function.
        handleSystemBackButton();
        
        // CRITICAL: Immediately push the state again. This "traps" the back button,
        // preventing the user from accidentally exiting the app. The next back press
        // will trigger this listener again instead of closing the browser tab.
        history.pushState({ page: 'home' }, 'Home', '#home');
    }); // Add this new function call
}


function runDeliveryAgent() {
    // This 'agent' runs in the background to mark incoming messages as 'delivered'.
    const contactsRef = db.ref(`users/${currentUser.uid}/contacts`);
    
    // When a contact is added, start listening to that chat for new messages to deliver.
    contactsRef.on('child_added', contactSnapshot => {
        const partnerUid = contactSnapshot.key;
        const chatId = getChatId(currentUser.uid, partnerUid);
        const messagesRef = db.ref(`messages/${chatId}`);

        // Listen for newly added messages in this chat.
        messagesRef.limitToLast(1).on('child_added', messageSnapshot => {
            const message = messageSnapshot.val();
            // If the last message was sent by the partner and is still marked 'sent',
            // update it to 'delivered'.
            if (message.sender === partnerUid && message.status === 'sent') {
                messageSnapshot.ref.update({ status: 'delivered' });
            }
        });
    });
}

// --- Real-time Presence System ---
function manageUserPresence() {
    const myUid = auth.currentUser.uid;
    const userStatusDatabaseRef = db.ref('/status/' + myUid);

    // We'll create two constants which we will write to 
    // the Realtime Database when this device is offline
    // or online.
    const isOfflineForDatabase = {
        state: 'offline',
        last_changed: firebase.database.ServerValue.TIMESTAMP,
    };
    const isOnlineForDatabase = {
        state: 'online',
        last_changed: firebase.database.ServerValue.TIMESTAMP,
    };

    // Create a reference to the special '.info/connected' path in 
    // Realtime Database. This path returns `true` when connected
    // and `false` when disconnected.
    db.ref('.info/connected').on('value', function(snapshot) {
        // If we're not connected, don't do anything.
        if (snapshot.val() == false) {
            return;
        };

        // If we are connected, then use the 'onDisconnect()' 
        // Ccrucially, this sets the PRESENCE DATA WHEN THE USER DISCONNECTS
        userStatusDatabaseRef.onDisconnect().set(isOfflineForDatabase).then(function() {
            // The onDisconnect() set is ready to go, so we can now safely set the
            // online state.
            userStatusDatabaseRef.set(isOnlineForDatabase);
        });
    });
}

// --- NAVIGATION ---
document.getElementById('nav-home').addEventListener('click', () => showPanel('home-content'));
document.getElementById('nav-notifications').addEventListener('click', () => showPanel('notifications-content'));
document.getElementById('nav-calls').addEventListener('click', () => showPanel('calls-content'));
document.getElementById('menu-btn').addEventListener('click', () => showProfileModal());
document.getElementById('add-friend-btn').addEventListener('click', () => showModal('add-friend-modal'));
document.getElementById('close-add-friend-modal-btn').addEventListener('click', () => showModal('add-friend-modal', false));
document.getElementById('back-to-main-btn').addEventListener('click', () => {
    showView('main-view'); 
    currentChatPartner = null;
    if (window.currentChatListener) db.ref(window.currentChatListener.path).off('child_added', window.currentChatListener.callback);
    // This is crucial to stop listening when you leave the chat
    if (window.currentStatusListener) window.currentStatusListener.ref.off('value', window.currentStatusListener.callback);
});

// --- THEME SWITCH LOGIC ---
const themeSwitchContainer = document.getElementById('theme-switch-container');
const themeSwitchIcon = document.getElementById('theme-switch-icon');
const themeSwitchText = document.getElementById('theme-switch-text');
const appContainer = document.getElementById('app-container');
const sunIcon = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 5.64c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l1.06 1.06c.39.39 1.02.39 1.41 0s.39-1.02 0-1.41L5.64 5.64zm12.73 12.73c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l1.06 1.06c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41l-1.06-1.06zm1.06-10.61c.39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.02 0 1.41s1.02.39 1.41 0l1.06-1.06zM5.64 18.36c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0l-1.06-1.06c-.39-.39-.39 1.02 0-1.41s1.02-.39 1.41 0l1.06 1.06z"></path></svg>`;
const moonIcon = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M9.37 5.51c-.18.64.27 1.21.91 1.21.49 0 .9-.36.98-.85C12.38 2.9 14.28.99 16.5.99c2.21 0 4.11 1.9 4.49 4.51.08.49.49.85.98.85.64 0 1.09-.57.91-1.21-.49-1.72-1.99-3.05-3.79-3.56-1.8-.52-3.77.16-5.05 1.44-1.28 1.28-1.96 3.25-1.47 5.05z"></path></svg>`;
const setTheme = (theme) => {
    if (theme === 'dark') {
        appContainer.classList.add('dark-mode');
        document.body.classList.add('dark-mode');
        themeSwitchIcon.innerHTML = moonIcon;
        themeSwitchText.textContent = 'Night Mode';
        localStorage.setItem('theme', 'dark');
    } else {
        appContainer.classList.remove('dark-mode');
        document.body.classList.remove('dark-mode');
        themeSwitchIcon.innerHTML = sunIcon;
        themeSwitchText.textContent = 'Day Mode';
        localStorage.setItem('theme', 'light');
    }
};
themeSwitchContainer.addEventListener('click', () => {
    const isDarkMode = appContainer.classList.contains('dark-mode');
    setTheme(isDarkMode ? 'light' : 'dark');
});
const savedTheme = localStorage.getItem('theme') || 'light';
setTheme(savedTheme);

// --- START: NEW SEARCH LOGIC ---
const mainHeader = document.querySelector('header.main-header');
const searchHeader = document.getElementById('search-header');
const searchInput = document.getElementById('search-input');

document.getElementById('search-btn').addEventListener('click', () => {
    mainHeader.style.display = 'none';
    searchHeader.style.display = 'block';
    searchInput.focus();
});

document.getElementById('close-search-btn').addEventListener('click', () => {
    mainHeader.style.display = 'block';
    searchHeader.style.display = 'none';
    searchInput.value = '';
    filterLists(); // Call with empty value to reset the list
});

searchInput.addEventListener('input', filterLists);

function filterLists() {
    const searchTerm = searchInput.value.toLowerCase();
    const activePanel = document.querySelector('.content-panel.active');
    if (!activePanel) return;

    const items = activePanel.querySelectorAll('.list-item');
    items.forEach(item => {
        const nameElement = item.querySelector('.list-item-name');
        if (nameElement) {
            const name = nameElement.textContent.toLowerCase();
            if (name.includes(searchTerm)) {
                item.style.display = 'flex';
            } else {
                item.style.display = 'none';
            }
        }
    });
}
// --- END: NEW SEARCH LOGIC ---



//---------

        // --- FRIEND SYSTEM --- [MODIFIED]
document.getElementById('send-friend-request-btn').addEventListener('click', () => {
    const friendId = document.getElementById('add-friend-id-input').value.trim(); if (!friendId) return;
    db.ref('users').orderByChild('jgId').equalTo(friendId).once('value', snapshot => {
        if (snapshot.exists()) {
            const friendUid = Object.keys(snapshot.val())[0];
            if(friendUid === currentUser.uid) return alert("You can't add yourself.");
            // Create a request with a 'type' for the new real-time system
            const request = { name: currentUser.name, emoji: currentUser.emoji, type: 'incoming' };
            db.ref(`requests/${friendUid}/${currentUser.uid}`).set(request).then(() => { 
                alert('Friend request sent!'); 
                showModal('add-friend-modal', false); 
                document.getElementById('add-friend-id-input').value = '';
            });
        } else { alert('User not found.'); }
    });
});
// =====================================================================================================
        
    function listenForFriendRequests() {
    db.ref(`requests/${currentUser.uid}`).on('value', snapshot => {
        const list = document.getElementById('notification-list');
        list.innerHTML = '';
        let incomingRequestCount = 0;
        if (snapshot.exists()) {
            snapshot.forEach(childSnapshot => {
                const request = childSnapshot.val();
                const fromUid = childSnapshot.key;

                if (currentUser.blocked && currentUser.blocked[fromUid]) return;

                const div = document.createElement('div');
                div.className = 'list-item';
                div.style.cursor = 'default'; // Non-actionable items shouldn't have pointer cursor

                const type = request.type || 'incoming'; // Default to 'incoming' for legacy requests

                switch (type) {
                    case 'incoming':
                        incomingRequestCount++;
                        div.innerHTML = `
                            <div class="list-item-emoji">${request.emoji}</div>
                            <div class="list-item-details">
                                <div class="list-item-name">${request.name}</div>
                                <div class="list-item-subtext">Wants to be your friend</div>
                            </div>
                            <div class="list-item-actions">
                                <button onclick="handleFriendRequest('${fromUid}', true)">Accept</button>
                                <button class="reject" onclick="handleFriendRequest('${fromUid}', false)">Reject</button>
                            </div>`;
                        break;
                    
                    case 'accepted':
                        div.innerHTML = `
                            <div class="list-item-emoji">${request.emoji}</div>
                            <div class="list-item-details">
                                <div class="list-item-name">${request.name}</div>
                                <div class="list-item-subtext">Accepted your friend request.</div>
                            </div>
                            <div class="list-item-actions">
                                <button class="reject" onclick="dismissNotification('${fromUid}')">Dismiss</button>
                            </div>`;
                        break;

                    case 'rejected':
                        div.innerHTML = `
                            <div class="list-item-emoji">${request.emoji}</div>
                            <div class="list-item-details">
                                <div class="list-item-name">${request.name}</div>
                                <div class="list-item-subtext">Declined your friend request.</div>
                            </div>
                            <div class="list-item-actions">
                                <button class="reject" onclick="dismissNotification('${fromUid}')">Dismiss</button>
                            </div>`;
                        break;
                }
                if (div.innerHTML) {
                    list.appendChild(div);
                }
            });
        }
        
        if (list.childElementCount === 0) {
            list.innerHTML = '<p style="text-align:center; color: #667781; padding: 40px 20px;">No new updates.</p>';
        }
        const badge = document.getElementById('notifications-badge');
        badge.textContent = incomingRequestCount;
        badge.style.display = incomingRequestCount > 0 ? 'block' : 'none';
    });
}
        // ====================================================================================================
        
        window.dismissNotification = (notificationId) => {
            db.ref(`requests/${currentUser.uid}/${notificationId}`).remove();
        };

        window.dismissNotification = (notificationId) => {
    db.ref(`requests/${currentUser.uid}/${notificationId}`).remove();
};

// ====================================================================================================
window.handleFriendRequest = (fromUid, accepted) => {
    // 1. Remove the original incoming request from the receiver's queue.
    db.ref(`requests/${currentUser.uid}/${fromUid}`).remove();

    // 2. Create a notification object to send back to the original sender.
    const notification = { 
        name: currentUser.name, 
        emoji: currentUser.emoji, 
        type: accepted ? 'accepted' : 'rejected' 
    };

    // 3. Send the notification back to the sender's request queue.
    // This triggers a real-time update on the sender's client via listenForFriendRequests.
    db.ref(`requests/${fromUid}/${currentUser.uid}`).set(notification);

    // 4. If accepted, add each user to the other's contact list.
    // This triggers the real-time update of the contact lists on both clients.
    if (accepted) {
        db.ref(`users/${currentUser.uid}/contacts/${fromUid}`).set(true);
        db.ref(`users/${fromUid}/contacts/${currentUser.uid}`).set(true);
    }
}
// ====================================================================================================

// --- DELETE THE FAULTY listenAndRenderContacts AND REPLACE IT WITH THIS FINAL, CORRECT VERSION ---

/**
 * The definitive, robust function to listen for and render the sorted chat list,
 * preventing any duplicate entries.
 */
function listenAndRenderContacts() {
    const contactList = document.getElementById('contact-list');
    const contactsRef = db.ref(`users/${currentUser.uid}/contacts`);
    const metadataRef = db.ref(`chatMetadata/${currentUser.uid}`);

    // This object will hold the current state of all chats.
    let chatListState = {};

    // This is our single, master render function.
    const renderList = () => {
        // Convert the state object into an array and sort it.
        const sortedChats = Object.values(chatListState).sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);

        // Always clear the list before re-rendering.
        contactList.innerHTML = '';

        if (sortedChats.length === 0) {
            contactList.innerHTML = '<p style="text-align:center; color: var(--wa-text-secondary); padding: 40px 20px;">Add a friend to start chatting!</p>';
            return;
        }

        // Loop through the sorted data and append each item to the DOM.
        sortedChats.forEach(contactData => {
            contactList.appendChild(contactData.domElement);
        });
    };

    // --- DATA LISTENERS ---

    // Listen for when contacts are ADDED
    contactsRef.on('child_added', (contactSnap) => {
        const partnerUid = contactSnap.key;

        db.ref(`users/${partnerUid}`).once('value', (userSnap) => {
            if (!userSnap.exists()) return;

            const contact = { uid: userSnap.key, ...userSnap.val() };
            const chatId = getChatId(currentUser.uid, partnerUid);

            // Create the DOM element for this contact ONCE.
            const div = document.createElement('div');
            div.className = 'list-item';
            div.id = `contact-item-${contact.uid}`;
            div.innerHTML = `
                ${createUserPfp(contact, 'list-item-pfp')}
                <div class="list-item-details">
                    <div class="list-item-name">${contact.name}</div>
                    <div class="list-item-subtext" id="unread-count-${chatId}">Click to open chat</div>
                    <div id="status-dot-${contact.uid}" class="status-dot offline"></div>
                </div>
            `;
            
            // Attach click handlers ONCE.
            if (contact.photoURL) {
                div.querySelector('.list-item-pfp').onclick = (e) => { e.stopPropagation(); openPfpViewer(contact.photoURL); };
            }
            div.onclick = () => openChat(contact.uid, contact);

            // Store this contact's state in our central object.
            chatListState[partnerUid] = {
                uid: partnerUid,
                lastMessageTimestamp: 0, // Default timestamp
                domElement: div // Store the created element
            };

            // Attach listeners for this specific contact.
            db.ref(`/status/${partnerUid}`).on('value', statusSnap => {
                const statusDot = div.querySelector(`#status-dot-${partnerUid}`);
                if (statusDot) {
                    const status = statusSnap.val();
                    statusDot.classList.toggle('online', status?.state === 'online');
                    statusDot.classList.toggle('offline', status?.state !== 'online');
                }
            });

            db.ref(`unreadCounts/${currentUser.uid}/${chatId}`).on('value', unreadSnap => {
                const unreadElem = div.querySelector(`#unread-count-${chatId}`);
                if (unreadElem) {
                    const count = unreadSnap.val() || 0;
                    unreadElem.textContent = count > 0 ? `${count} new message${count > 1 ? 's' : ''}` : 'Click to open chat';
                }
            });

            // Trigger an initial render.
            renderList();
        });
    });

    // Listen for when contacts are REMOVED
    contactsRef.on('child_removed', (contactSnap) => {
        const partnerUid = contactSnap.key;
        // Detach listeners to prevent memory leaks
        db.ref(`/status/${partnerUid}`).off();
        const chatId = getChatId(currentUser.uid, partnerUid);
        db.ref(`unreadCounts/${currentUser.uid}/${chatId}`).off();
        // Remove from our state and re-render the list
        delete chatListState[partnerUid];
        renderList();
    });
    
    // Listen for TIMESTAMP changes, which triggers sorting
    metadataRef.on('value', (metadataSnap) => {
        const allMetadata = metadataSnap.val() || {};
        let needsRender = false;
        
        // Update the timestamps in our state object
        for (const chatId in allMetadata) {
            const partnerUid = chatId.replace(currentUser.uid, '').replace('_', '');
            if (chatListState[partnerUid] && chatListState[partnerUid].lastMessageTimestamp !== allMetadata[chatId].lastMessageTimestamp) {
                chatListState[partnerUid].lastMessageTimestamp = allMetadata[chatId].lastMessageTimestamp;
                needsRender = true;
            }
        }
        
        // Only re-render if a timestamp actually changed.
        if (needsRender) {
            renderList();
        }
    });
}



// --- REPLACE YOUR ENTIRE OLD openChat FUNCTION WITH THIS NEW, COMPLETE VERSION ---

async function openChat(partnerUid, partnerData) {
    if (currentUser.blocked && currentUser.blocked[partnerUid]) return alert(`This user is blocked. Unblock them from your profile to interact.`);
    currentChatPartner = { uid: partnerUid, ...partnerData };
    const chatId = getChatId(currentUser.uid, partnerUid);

    // --- Update UI ---
    const chatHeaderPfp = document.getElementById('chat-header-pfp');
    const chatHeaderName = document.getElementById('chat-header-name'); // Get reference to the name element

    // Clear previous event listeners to prevent memory leaks
    chatHeaderPfp.onclick = null;
    chatHeaderName.onclick = null;
    chatHeaderName.classList.remove('copied-feedback'); // Reset feedback class

    chatHeaderPfp.innerHTML = '';
    chatHeaderPfp.onclick = () => openPfpViewer(partnerData.photoURL);

    if (partnerData.photoURL) {
        const img = document.createElement('img');
        img.src = partnerData.photoURL;
        img.alt = partnerData.name;
        chatHeaderPfp.appendChild(img);
    } else {
        chatHeaderPfp.textContent = partnerData.emoji;
    }
    
    chatHeaderName.textContent = partnerData.name;
    
    // --- START: NEW CLICK-TO-COPY LOGIC ---
    chatHeaderName.onclick = () => {
        const idToCopy = partnerData.jgId;
        const originalName = partnerData.name;

        if (!idToCopy) {
            alert("This user does not have a dsAlgo ID.");
            return;
        }

        // Use our universal copy function
        copyTextToClipboard(idToCopy).then(() => {
            // Provide visual feedback
            chatHeaderName.textContent = 'ID Copied!';
            chatHeaderName.classList.add('copied-feedback');

            // Revert back to the original name after 1.5 seconds
            setTimeout(() => {
                chatHeaderName.textContent = originalName;
                chatHeaderName.classList.remove('copied-feedback');
            }, 1500);
        }).catch(err => {
            console.error("Failed to copy ID:", err);
            alert("Could not copy the ID.");
        });
    };
    // --- END: NEW CLICK-TO-COPY LOGIC ---

    document.getElementById('chat-messages').innerHTML = '';
    db.ref(`unreadCounts/${currentUser.uid}/${chatId}`).set(0);

    // --- Real-time Status Listener ---
    const statusDotHeader = document.querySelector('#chat-header-status .status-dot');
    const statusTextHeader = document.getElementById('chat-header-status-text');
    if (window.currentStatusListener) window.currentStatusListener.ref.off('value', window.currentStatusListener.callback);
    const statusRef = db.ref(`/status/${partnerUid}`);
    const statusCallback = snapshot => {
        const status = snapshot.val();
        if (status && status.state === 'online') {
            statusDotHeader.classList.replace('offline', 'online');
            statusTextHeader.textContent = 'Online';
        } else {
            statusDotHeader.classList.replace('online', 'offline');
            statusTextHeader.textContent = 'Offline';
        }
    };
    statusRef.on('value', statusCallback);
    window.currentStatusListener = { ref: statusRef, callback: statusCallback };

    // --- "Mark as Seen" Logic ---
    const messagesToUpdateRef = db.ref(`messages/${chatId}`);
    messagesToUpdateRef.orderByChild('sender').equalTo(partnerUid).once('value', snapshot => {
        const updates = {};
        snapshot.forEach(childSnapshot => {
            if (childSnapshot.val().status !== 'seen') {
                updates[childSnapshot.key + '/status'] = 'seen';
            }
        });
        if (Object.keys(updates).length > 0) {
            messagesToUpdateRef.update(updates);
        }
    });

    // --- Message Display & Deletion Logic ---
    const messagesRef = db.ref(`messages/${chatId}`).limitToLast(50);
    if (window.currentChatListener) {
        db.ref(window.currentChatListener.path).off(); // Turn off all previous listeners for this path
    }

    const messageAddedCallback = snapshot => {
        const msg = snapshot.val();
        const messageId = snapshot.key;
        
        const div = document.createElement('div');
        div.className = 'message-bubble ' + (msg.sender === currentUser.uid ? 'message-sent' : 'message-received');
        div.dataset.id = messageId;

        div.addEventListener('mousedown', handleLongPressStart);
        div.addEventListener('mouseup', handleLongPressEnd);
        div.addEventListener('mouseleave', handleLongPressEnd);
        div.addEventListener('touchstart', handleLongPressStart, { passive: false });
        div.addEventListener('touchend', handleLongPressEnd);

        const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        let metaHTML = `<div class="message-meta"><span class="timestamp">${time}</span>`;
        if (msg.sender === currentUser.uid) {
            let ticksSVG = '', blueClass = '';
            if (msg.status === 'seen') {
                ticksSVG = `<svg viewBox="0 0 24 24"><path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z"/></svg>`;
                blueClass = 'blue-ticks';
            } else if (msg.status === 'delivered') {
                ticksSVG = `<svg viewBox="0 0 24 24"><path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z"/></svg>`;
            } else { // 'sent'
                ticksSVG = `<svg viewBox="0 0 24 24"><path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"/></svg>`;
            }
            metaHTML += `<span class="ticks ${blueClass}">${ticksSVG}</span>`;
        }
        metaHTML += `</div>`;
        div.innerHTML = `<span>${msg.text}</span>${metaHTML}`;
        document.getElementById('chat-messages').appendChild(div);
        document.getElementById('chat-messages').scrollTop = document.getElementById('chat-messages').scrollHeight;
    };
    
    const messageRemovedCallback = snapshot => {
        const removedMessageId = snapshot.key;
        const elementToRemove = document.querySelector(`.message-bubble[data-id="${removedMessageId}"]`);
        if (elementToRemove) {
            elementToRemove.remove();
        }
    };

    messagesRef.on('child_added', messageAddedCallback);
    messagesRef.on('child_removed', messageRemovedCallback);
    
    window.currentChatListener = {
        path: `messages/${chatId}`,
        addedCallback: messageAddedCallback,
        removedCallback: messageRemovedCallback
    };
    
    showView('chat-view');
}

      


        document.getElementById('chat-send-btn').addEventListener('click', sendMessage);
        document.getElementById('chat-input').addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
        
// --- REPLACE YOUR ENTIRE OLD sendMessage FUNCTION WITH THIS NEW ONE ---

function sendMessage() {
    const input = document.getElementById('chat-input'); 
    const text = input.value.trim(); 
    if (!text || !currentChatPartner) return;
    if (currentChatPartner.blocked && currentChatPartner.blocked[currentUser.uid]) return alert("You have been blocked by this user.");
    
    const chatId = getChatId(currentUser.uid, currentChatPartner.uid);
    const messageData = {
        text: text,
        sender: currentUser.uid,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        status: 'sent'
    };

    // Push the new message
    db.ref(`messages/${chatId}`).push(messageData);
    
    // --- START: NEW TIMESTAMP TRACKING ---
    // This update is critical. It updates a metadata record for both users,
    // which will trigger the list to re-sort in real-time.
    const lastMessageUpdate = {
        lastMessageTimestamp: firebase.database.ServerValue.TIMESTAMP
    };
    const updates = {};
    updates[`chatMetadata/${currentUser.uid}/${chatId}`] = lastMessageUpdate;
    updates[`chatMetadata/${currentChatPartner.uid}/${chatId}`] = lastMessageUpdate;
    db.ref().update(updates);
    // --- END: NEW TIMESTAMP TRACKING ---

    db.ref(`unreadCounts/${currentChatPartner.uid}/${chatId}`).transaction(count => (count || 0) + 1); 
    input.value = '';
}

        function listenForUnreadMessages() {
            db.ref(`unreadCounts/${currentUser.uid}`).on('value', snapshot => {
                let totalUnread = 0;
                snapshot.forEach(chatSnap => {
                    const count = chatSnap.val(); totalUnread += count;
                    const unreadElem = document.getElementById(`unread-count-${chatSnap.key}`);
                    if (unreadElem) unreadElem.textContent = count > 0 ? `${count} new message${count > 1 ? 's' : ''}` : 'Click to open chat';
                });
                const badge = document.getElementById('home-badge'); badge.textContent = totalUnread; badge.style.display = totalUnread > 0 ? 'block' : 'none';
            });
        }
        
        // --- WEBRTC CALLING ---
        document.getElementById('video-call-btn').addEventListener('click', () => startCall(true));
        document.getElementById('voice-call-btn').addEventListener('click', () => startCall(false));

        
        // --- REPLACE YOUR ENTIRE OLD startCall FUNCTION WITH THIS NEW ONE ---


// --- REPLACE YOUR ENTIRE OLD startCall FUNCTION WITH THIS NEW, ROBUST VERSION ---

async function startCall(isVideo) {
    if (!currentChatPartner || (currentUser.blocked && currentUser.blocked[currentChatPartner.uid])) return alert(`You cannot call a blocked user.`);
    currentCallData = { id: db.ref('calls').push().key, isVideo, caller: { uid: currentUser.uid, ...currentUser }, calleeId: currentChatPartner.uid };
    
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });
        if (isVideo) { 
            document.getElementById('local-video').srcObject = localStream; 
        }
        peerConnection = new RTCPeerConnection(stunServers);
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        peerConnection.onicecandidate = e => { if (e.candidate) db.ref(`iceCandidates/${currentCallData.id}/caller`).push(e.candidate.toJSON()); };
        
        // --- START: DEFINITIVE ontrack HANDLER ---
        peerConnection.ontrack = e => { 
            console.log("Remote track received.");
            remoteStream = e.streams[0]; 
            const remoteMediaElement = document.getElementById(currentCallData.isVideo ? 'remote-video' : 'remote-audio');
            remoteMediaElement.srcObject = remoteStream;

            // This is the definitive fix for audio calls.
            if (!currentCallData.isVideo) {
                console.log("Attempting to play remote audio...");
                // Explicitly unmute the element before playing. This is CRITICAL.
                remoteMediaElement.muted = false; 
                remoteMediaElement.play().catch(error => console.error("Remote audio play failed:", error));
            }
        };
        // --- END: DEFINITIVE ontrack HANDLER ---

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        await db.ref(`calls/${currentCallData.calleeId}`).set({ ...currentCallData, offer: { type: offer.type, sdp: offer.sdp }});
        
        listenForCallAnswer(currentCallData.id);
        showCallUI(isVideo, 'Calling...', currentChatPartner);

    } catch (error) {
        console.error("Error starting call: ", error);
        // ... (error handling remains the same)
        cleanupCall();
    }
}



        
        
        function listenForCallAnswer(callId) {
            db.ref(`calls/${currentCallData.calleeId}`).on('value', async snapshot => {
                const data = snapshot.val();
                if (data && data.answer && peerConnection.signalingState !== "stable") {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    listenForRemoteIceCandidates(callId, 'callee');
                    // From the caller's perspective, the contact is still the currentChatPartner
                    showCallUI(currentCallData.isVideo, 'Connected', currentChatPartner);
                } else if (!data) { endCall(); }
            });
        }
        
// --- THIS IS THE NEW, COMPLETE CODE TO REPLACE IT WITH ---

/**
 * Listens for incoming calls and robustly handles new, answered, and missed call scenarios.
 */
function listenForIncomingCalls() {
    const myCallRef = db.ref(`calls/${currentUser.uid}`);

    myCallRef.on('value', async (snapshot) => {
        const callData = snapshot.val();
        const incomingCallModal = document.getElementById('incoming-call-modal');

        // SCENARIO 1: A new call is initiated by someone else.
        if (callData && !currentCallData) {
            console.log("Incoming call detected.");
            if (currentUser.blocked && currentUser.blocked[callData.caller.uid]) {
                myCallRef.remove(); // Silently reject if the caller is blocked.
                return;
            }
            currentCallData = callData;

            // Display the incoming call modal
            const callerPfpHtml = createUserPfp(callData.caller, 'profile-emoji-display');
            const infoDiv = document.getElementById('incoming-caller-info');
            infoDiv.querySelector('.profile-emoji-display').outerHTML = callerPfpHtml;
            infoDiv.querySelector('.name').textContent = callData.caller.name;
            showModal('incoming-call-modal');
            ringtone.play();
        }

        // SCENARIO 2: The call was MISSED.
        // This triggers if `callData` becomes null WHILE the incoming call modal is still visible.
        else if (!callData && currentCallData && incomingCallModal.style.display === 'flex') {
            console.log("Detected a MISSED call.");
            
            // Log the call as 'missed' BEFORE cleaning up the UI.
            logCall('missed'); 

            // Clean up the UI for the missed call.
            showModal('incoming-call-modal', false);
            ringtone.pause();
            ringtone.currentTime = 0;
            currentCallData = null; // Reset the state.
        }
    });
}
        
        // --- REPLACE YOUR ENTIRE OLD 'accept-call-btn' EVENT LISTENER WITH THIS NEW ONE ---

// --- REPLACE YOUR ENTIRE OLD 'accept-call-btn' EVENT LISTENER WITH THIS FINAL VERSION ---

document.getElementById('accept-call-btn').addEventListener('click', async () => {
    showModal('incoming-call-modal', false); ringtone.pause(); ringtone.currentTime = 0;
    const { isVideo, id: callId, offer } = currentCallData;
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });
        if (isVideo) { document.getElementById('local-video').srcObject = localStream; }
        peerConnection = new RTCPeerConnection(stunServers);
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        peerConnection.onicecandidate = e => { if (e.candidate) db.ref(`iceCandidates/${callId}/callee`).push(e.candidate.toJSON()); };

        // --- START: DEFINITIVE ontrack HANDLER ---
        peerConnection.ontrack = e => { 
            console.log("Remote track received.");
            remoteStream = e.streams[0]; 
            const remoteMediaElement = document.getElementById(currentCallData.isVideo ? 'remote-video' : 'remote-audio');
            remoteMediaElement.srcObject = remoteStream;

            // This is the definitive fix for audio calls.
            if (!currentCallData.isVideo) {
                console.log("Attempting to play remote audio...");
                // Explicitly unmute the element before playing. This is CRITICAL.
                remoteMediaElement.muted = false;
                remoteMediaElement.play().catch(error => console.error("Remote audio play failed:", error));
            }
        };
        // --- END: DEFINITIVE ontrack HANDLER ---

        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer(); await peerConnection.setLocalDescription(answer);
        await db.ref(`calls/${currentUser.uid}`).update({ answer: { type: answer.type, sdp: answer.sdp }});
        listenForRemoteIceCandidates(callId, 'caller');
        showCallUI(isVideo, 'Connected', currentCallData.caller);
    } catch(error) { console.error("Error accepting call:", error); alert("Could not accept call."); cleanupCall(); }
});

        
        document.getElementById('reject-call-btn').addEventListener('click', () => { showModal('incoming-call-modal', false); ringtone.pause(); ringtone.currentTime = 0; db.ref(`calls/${currentUser.uid}`).remove(); logCall('rejected'); currentCallData = null; });
        function listenForRemoteIceCandidates(callId, role) { db.ref(`iceCandidates/${callId}/${role}`).on('child_added', s => { if (s.exists()) peerConnection.addIceCandidate(new RTCIceCandidate(s.val())); }); }
        
    function showCallUI(isVideo, status, contactForUi) {
    const viewId = isVideo ? 'video-call-view' : 'voice-call-view';
    const background = document.querySelector(`#${viewId} .call-background img`);
    const callerInfo = document.getElementById(isVideo ? 'video-caller-info' : 'voice-caller-info');
    const emojiDiv = callerInfo.querySelector('.emoji');
    
    // 1. Set the blurry background image
    if (contactForUi && contactForUi.photoURL) {
        background.src = contactForUi.photoURL;
        background.style.display = 'block';
    } else {
        background.style.display = 'none'; // Hide if no photo is available
    }
    
    // 2. Set the smaller, non-blurry PFP in the center
    emojiDiv.innerHTML = ''; // Clear any previous content
    if (contactForUi && contactForUi.photoURL) {
        const img = document.createElement('img');
        img.src = contactForUi.photoURL;
        emojiDiv.appendChild(img);
    } else if (contactForUi) {
        emojiDiv.textContent = contactForUi.emoji;
    }

    // 3. Set the name and status text
    callerInfo.querySelector('.name').textContent = contactForUi ? contactForUi.name : 'Unknown';
    callerInfo.querySelector('.status').textContent = status;
    
    showView(viewId);
}

        document.getElementById('end-video-call-btn').addEventListener('click', endCall);
        document.getElementById('end-voice-call-btn').addEventListener('click', endCall);
        function endCall() { logCall('ended'); cleanupCall(); }
        // --- THIS IS THE NEW, COMPREHENSIVE CODE TO REPLACE IT WITH ---

/**
 * A robust function to completely clean up and reset all call-related state,
 * including listeners, connections, media streams, and UI elements.
 */
function cleanupCall() {
    console.log("Cleaning up call resources...");

    // 1. Detach all Firebase listeners related to the current call (CRITICAL FIX)
    if (currentCallData) {
        // The main call object listener (for answers and hang-ups)
        const otherUserId = currentCallData.caller.uid === currentUser.uid ? currentCallData.calleeId : currentCallData.caller.uid;
        db.ref(`calls/${otherUserId}`).off();
        db.ref(`calls/${currentUser.uid}`).off();

        // All ICE candidate listeners for this specific call ID
        db.ref(`iceCandidates/${currentCallData.id}`).off();
    }

    // 2. Close the WebRTC peer connection and remove its event handlers
    if (peerConnection) {
        peerConnection.ontrack = null;
        peerConnection.onicecandidate = null;
        peerConnection.close();
        peerConnection = null;
    }

    // 3. Stop and release the user's camera and microphone tracks
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
    }

    // 4. Clear all media element sources to prevent stale streams (CRITICAL FIX)
    document.getElementById('remote-video').srcObject = null;
    document.getElementById('remote-audio').srcObject = null;
    document.getElementById('local-video').srcObject = null;

    // 5. Clean up the database entries for the call
    if (currentCallData) {
        const otherUserId = currentCallData.caller.uid === currentUser.uid ? currentCallData.calleeId : currentCallData.caller.uid;
        db.ref(`calls/${otherUserId}`).remove();
        db.ref(`calls/${currentUser.uid}`).remove();
        db.ref(`iceCandidates/${currentCallData.id}`).remove();
    }
    
    // 6. Reset the global call state variable
    currentCallData = null; 

    // 7. Return to the correct view (stay in chat if possible, otherwise main view)
    if (currentChatPartner) {
        // If we were in a chat, just hide the call view and show the chat again.
        showView('chat-view');
    } else {
        showView('main-view');
    }
}
        function logCall(status) {
             if (!currentCallData) return;
             const partner = currentCallData.caller.uid === currentUser.uid ? currentChatPartner : currentCallData.caller; if(!partner) return;
             //db.ref(`callLogs/${currentUser.uid}`).push({ partnerName: partner.name, partnerEmoji: partner.emoji, type: currentCallData.isVideo ? 'video' : 'voice', status, timestamp: firebase.database.ServerValue.TIMESTAMP });

             db.ref(`callLogs/${currentUser.uid}`).push({ partnerName: partner.name, partnerEmoji: partner.emoji, partnerPhotoURL: partner.photoURL || null, type: currentCallData.isVideo ? 'video' : 'voice', status, timestamp: firebase.database.ServerValue.TIMESTAMP });
        }  
        // --- THIS IS THE NEW, CORRECTED CODE TO REPLACE IT WITH ---

/**
 * Listens for changes to the call log and correctly renders the list
 * with the most recent call always on top.
 */
function renderCallLogs() {
    const list = document.getElementById('call-log-list');
    const callLogsRef = db.ref(`callLogs/${currentUser.uid}`);

    // Listen for any change in the call logs data.
    callLogsRef.orderByChild('timestamp').limitToLast(50).on('value', (snapshot) => {
        
        // 1. CRITICAL FIX: Always clear the entire list before re-rendering.
        list.innerHTML = ''; 

        // 2. Handle the case where there are no call logs.
        if (!snapshot.exists()) {
            list.innerHTML = '<p style="text-align:center; color: #667781; padding: 40px 20px;">No recent calls.</p>';
            return; // Stop the function here.
        }

        // 3. Create a temporary array to hold the logs.
        const logs = [];
        snapshot.forEach(child => {
            logs.push(child.val());
        });

        // 4. Reverse the array to ensure the newest call (last in the snapshot) is first.
        logs.reverse();

        // 5. Loop through the reversed array and create the HTML for each log entry.
        logs.forEach(log => {
            const div = document.createElement('div');
            div.className = 'list-item';
            
            const logPartner = { emoji: log.partnerEmoji, photoURL: log.partnerPhotoURL };
            const logPfpHtml = createUserPfp(logPartner, 'list-item-pfp');

            // Format the date and status for display
            const callDate = new Date(log.timestamp).toLocaleString();
            const callStatus = log.status.charAt(0).toUpperCase() + log.status.slice(1); // Capitalize first letter

            div.innerHTML = `
                ${logPfpHtml}
                <div class="list-item-details">
                    <div class="list-item-name">${log.partnerName} (${log.type})</div>
                    <div class="list-item-subtext">${callStatus} - ${callDate}</div>
                </div>
            `;
            
            list.appendChild(div);   
        });
    });
}
        
// --- Replace the entire old showProfileModal function with this new one ---
function showProfileModal() {
    // Display Logic (PFP/Emoji part remains the same)
    const pfp = document.getElementById('profile-pfp-display');
    const emoji = document.getElementById('profile-emoji-display');
    if (currentUser.photoURL) {
        pfp.src = currentUser.photoURL;
        pfp.style.display = 'block';
        emoji.style.display = 'none';
    } else {
        pfp.style.display = 'none';
        emoji.style.display = 'flex';
        emoji.textContent = currentUser.emoji;
    }

    // --- START OF MODIFICATION ---
    // This generates the new vertical layout for the user details
    document.getElementById('profile-details-display').innerHTML = `
        <p class="profile-name">${currentUser.name}</p>
        <div class="profile-id-container">
            <p><strong>ID:</strong> ${currentUser.jgId}</p>
            <button id="copy-id-btn">COPY</button>
        </div>
    `;
    
    // Add the event listener for the new copy button

document.getElementById('copy-id-btn').addEventListener('click', () => {
    // Call our new universal copy function
    copyTextToClipboard(currentUser.jgId).then(() => {
        // This is the success feedback for the user
        const copyBtn = document.getElementById('copy-id-btn');
        copyBtn.textContent = 'COPIED!';
        copyBtn.classList.add('copied');
        setTimeout(() => {
            copyBtn.textContent = 'COPY';
            copyBtn.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        // This is the error feedback for the user
        console.error('Failed to copy ID: ', err);
        alert("Could not copy ID. Please try copying it manually.");
    });
});
    // --- END OF MODIFICATION ---

    // Set initial values for edit form
    document.getElementById('edit-profile-name').value = currentUser.name;
    document.getElementById('edit-profile-emoji').value = currentUser.emoji;
    document.getElementById('pfp-upload-input').value = '';
    document.querySelector('.pfp-upload-label').textContent = 'Change Profile Picture';

    // Reset view to display mode
    document.getElementById('profile-info-display').style.display = 'block';
    document.getElementById('profile-edit-form').style.display = 'none';
    document.getElementById('edit-profile-btn').style.display = 'inline-block';
    document.getElementById('save-profile-changes-btn').style.display = 'none';
    
    renderBlockedUsers();
    showModal('profile-view-modal');
}


document.getElementById('close-profile-modal-btn').addEventListener('click', () => showModal('profile-view-modal', false));

document.getElementById('edit-profile-btn').addEventListener('click', () => {
    document.getElementById('profile-info-display').style.display = 'none';
    document.getElementById('profile-edit-form').style.display = 'block';
    document.getElementById('edit-profile-btn').style.display = 'none';
    document.getElementById('save-profile-changes-btn').style.display = 'inline-block';
});

document.getElementById('pfp-upload-input').addEventListener('change', (e) => {
    const label = document.querySelector('.pfp-upload-label');
    if (e.target.files && e.target.files.length > 0) {
        label.textContent = e.target.files[0].name;
    } else {
        label.textContent = 'Change Profile Picture';
    }
});

document.getElementById('save-profile-changes-btn').addEventListener('click', async () => {
    const name = document.getElementById('edit-profile-name').value;
    const emoji = document.getElementById('edit-profile-emoji').value;
    const file = document.getElementById('pfp-upload-input').files[0];
    const updates = { name, emoji };

    if (!name || !emoji) return alert("Name and Emoji cannot be empty.");

    const saveBtn = document.getElementById('save-profile-changes-btn');
    saveBtn.textContent = "Saving...";
    saveBtn.disabled = true;

    try {
        if (file) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('upload_preset', 'chatting_app_preset');
            const CLOUDINARY_URL = `https://api.cloudinary.com/v1_1/ddsrcsknl/image/upload`;
            const response = await fetch(CLOUDINARY_URL, { method: 'POST', body: formData });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Cloudinary upload failed: ${errorData.error.message}`);
            }
            const data = await response.json();
            updates.photoURL = data.secure_url; 
        }
        await db.ref(`users/${currentUser.uid}`).update(updates);
    } catch (error) {
        console.error("Error updating profile: ", error);
        alert(`Failed to update profile. ${error.message}`);
    } finally {
        saveBtn.textContent = "Save";
        saveBtn.disabled = false;
        showProfileModal();
    }
});

document.getElementById('remove-pfp-btn').addEventListener('click', async () => {
    if (!currentUser.photoURL) return alert("No profile picture to remove.");
    if (!confirm("Are you sure you want to remove your profile picture?")) return;
    try {
        await db.ref(`users/${currentUser.uid}/photoURL`).remove();
        alert("Profile picture removed.");
        showProfileModal();
    } catch (error) {
        console.error("Error removing picture reference: ", error);
        alert("Could not remove profile picture.");
    }
});

document.getElementById('chat-more-btn').addEventListener('click', () => { if(!currentChatPartner) return; if (confirm(`Are you sure you want to block ${currentChatPartner.name}?`)) blockUser(currentChatPartner.uid); });

function blockUser(uidToBlock) { db.ref(`users/${currentUser.uid}/blocked/${uidToBlock}`).set(true).then(() => { alert('User blocked.'); db.ref(`users/${currentUser.uid}/contacts/${uidToBlock}`).remove(); showView('main-view'); }); }

window.unblockUser = (uidToUnblock) => {
    db.ref(`users/${currentUser.uid}/blocked/${uidToUnblock}`).remove().then(() => {
        alert('User unblocked. You can now add them as a friend again.');
        renderBlockedUsers();
    });
}

function renderBlockedUsers() {
    const list = document.getElementById('blocked-users-list'); list.innerHTML = '';
    db.ref(`users/${currentUser.uid}/blocked`).once('value', snapshot => {
        if (!snapshot.exists()) { list.innerHTML = '<p style="font-size:12px; text-align:center; color: #667781;">No users blocked.</p>'; return; }
        snapshot.forEach(childSnapshot => {
            db.ref(`users/${childSnapshot.key}`).once('value', userSnap => {
                if (userSnap.exists()) {
                    const user = userSnap.val(); const item = document.createElement('div'); item.className = 'list-item';
                    const userPfpHtml = createUserPfp(user, 'list-item-pfp'); 
                    item.innerHTML = `${userPfpHtml}<div class="list-item-details"><div class="list-item-name">${user.name}</div></div><div class="list-item-actions"><button onclick="unblockUser('${childSnapshot.key}')">Unblock</button></div>`;
                    list.appendChild(item);
                }
            });
        });
    });
}




        document.getElementById('close-profile-modal-btn').addEventListener('click', () => showModal('profile-view-modal', false));
        
        
        document.getElementById('edit-profile-btn').addEventListener('click', () => { document.getElementById('profile-info-display').style.display = 'none'; document.getElementById('profile-edit-form').style.display = 'block'; document.getElementById('edit-profile-btn').style.display = 'none'; document.getElementById('save-profile-changes-btn').style.display = 'inline-block'; });
        
        
        
        
        // --- SAVE PROFILE CHANGES (WITH CLOUDINARY UPLOAD) ---
document.getElementById('save-profile-changes-btn').addEventListener('click', async () => {
    const name = document.getElementById('edit-profile-name').value;
    const emoji = document.getElementById('edit-profile-emoji').value;
    const file = document.getElementById('pfp-upload-input').files[0];
    const updates = { name, emoji };

    if (!name || !emoji) return alert("Name and Emoji cannot be empty.");

    const saveBtn = document.getElementById('save-profile-changes-btn');
    saveBtn.textContent = "Saving...";
    saveBtn.disabled = true;

    try {
        if (file) {
            // --- Cloudinary Upload Logic ---
            const formData = new FormData();
            formData.append('file', file);
            
            // *** REPLACE WITH YOUR UPLOAD PRESET NAME ***
            formData.append('upload_preset', 'chatting_app_preset'); 

            // *** REPLACE WITH YOUR CLOUD NAME ***
            const CLOUDINARY_URL = `https://api.cloudinary.com/v1_1/ddsrcsknl/image/upload`;

            const response = await fetch(CLOUDINARY_URL, {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Image upload failed.');
            }

            const data = await response.json();
            // Use the secure_url from the Cloudinary response
            updates.photoURL = data.secure_url; 
        }
        
        // Update the Firebase REALTIME DATABASE with new info
        await db.ref(`users/${currentUser.uid}`).update(updates);
        
    } catch (error) {
        console.error("Error updating profile: ", error);
        alert("Failed to update profile.");
    } finally {
        saveBtn.textContent = "Save";
        saveBtn.disabled = false;
        showProfileModal(); // Refresh and close edit view
    }
});
        
        // document.getElementById('save-profile-changes-btn').addEventListener('click', () => { db.ref(`users/${currentUser.uid}`).update({ name: document.getElementById('edit-profile-name').value, emoji: document.getElementById('edit-profile-emoji').value }); showProfileModal(); });
        
        
        document.getElementById('chat-more-btn').addEventListener('click', () => { if(!currentChatPartner) return; if (confirm(`Are you sure you want to block ${currentChatPartner.name}?`)) blockUser(currentChatPartner.uid); });
        function blockUser(uidToBlock) { db.ref(`users/${currentUser.uid}/blocked/${uidToBlock}`).set(true).then(() => { alert('User blocked.'); db.ref(`users/${currentUser.uid}/contacts/${uidToBlock}`).remove(); showView('main-view'); }); }
        

// ==========================

// --- ADD THIS ENTIRE BLOCK OF NEW CODE AT THE END OF YOUR SCRIPT ---

/**
 * Hides any currently visible message context menu.
 */
function hideContextMenu() {
    const existingMenu = document.getElementById('message-context-menu');
    if (existingMenu) {
        existingMenu.remove();
    }
}

// --- THIS IS THE NEW, FULLY COMPATIBLE CODE TO REPLACE IT WITH ---

// --- REPLACE YOUR ENTI-RE OLD showContextMenu FUNCTION WITH THIS NEW, FINAL VERSION ---

/**
 * Shows the Copy/Delete menu for a specific message bubble, using robust event
 * listeners and handlers for maximum mobile and desktop compatibility.
 * @param {HTMLElement} messageElement The message bubble div.
 */
function showContextMenu(messageElement) {
    hideContextMenu(); // Close any other open menus first

    const messageId = messageElement.dataset.id;
    if (!messageId) return;

    // Create the menu container
    const menu = document.createElement('div');
    menu.id = 'message-context-menu';
    menu.className = 'message-context-menu';

    // Intelligent Positioning Logic (remains the same)
    const rect = messageElement.getBoundingClientRect();
    const topThreshold = 120;
    if (rect.top < topThreshold) {
        menu.classList.add('menu-below');
    }

    // --- START: ROBUST "COPY" BUTTON ---
    const copyBtn = document.createElement('button');
    copyBtn.className = 'context-menu-btn';
    copyBtn.textContent = 'Copy';

    // Using addEventListener for better compatibility
    copyBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevents the global click listener from firing
        const messageText = messageElement.querySelector('span').textContent;
        
        // Use our universal copy function that works on mobile
        copyTextToClipboard(messageText).then(() => {
            copyBtn.textContent = 'Copied!';
            setTimeout(() => hideContextMenu(), 800);
        }).catch(err => {
            console.error('Failed to copy message: ', err);
            alert("Could not copy message.");
            hideContextMenu();
        });
    });
    // --- END: ROBUST "COPY" BUTTON ---

    // --- START: ROBUST "DELETE" BUTTON ---
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'context-menu-btn';
    deleteBtn.textContent = 'Delete';

    // Using addEventListener for better compatibility
    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevents the global click listener from firing
        
        // Hide menu immediately for a faster UI feel
        hideContextMenu();

        // Use a small timeout to allow the menu to disappear before the confirm dialog pops up
        setTimeout(() => {
            if (confirm('Delete this message for everyone? This cannot be undone.')) {
                const chatId = getChatId(currentUser.uid, currentChatPartner.uid);
                const messageRef = db.ref(`messages/${chatId}/${messageId}`);
                
                messageRef.remove().catch(error => {
                    console.error("Error deleting message: ", error);
                    alert("Could not delete the message. Please check your connection and try again.");
                });
            }
        }, 50); // 50ms delay
    });
    // --- END: ROBUST "DELETE" BUTTON ---

    menu.appendChild(copyBtn);
    menu.appendChild(deleteBtn);
    messageElement.appendChild(menu);
}

function handleLongPressStart(e) {
    e.preventDefault();
    const targetMessage = e.currentTarget;
    
    // Clear any previous timers
    clearTimeout(longPressTimer);
    
    // Start a new timer
    longPressTimer = setTimeout(() => {
        showContextMenu(targetMessage);
    }, 500); // 500ms for a long press
}

/**
 * Clears the long press timer if the press is released too early.
 * @param {Event} e The mouseup, mouseleave, or touchend event.
 */
function handleLongPressEnd(e) {
    clearTimeout(longPressTimer);
}

// Add a global click listener to close the menu when clicking elsewhere
document.getElementById('app-container').addEventListener('click', (e) => {
    // If the click is not on a menu button, hide the menu
    if (!e.target.classList.contains('context-menu-btn')) {
        hideContextMenu();
    }
});


// --- ADD THIS NEW FUNCTION AT THE END OF YOUR SCRIPT ---

/**
 * Hides the splash screen with a smooth fade-out animation.
 */
function hideSplashScreen() {
    const splash = document.getElementById('splash-screen');
    if (splash) {
        splash.classList.add('hidden');
        // After the animation, set display to none so it doesn't block clicks
        setTimeout(() => {
            splash.style.display = 'none';
        }, 500); // This duration must match the CSS transition duration
    }
}
//============================================
// --- ADD THIS ENTIRE NEW FUNCTION AT THE END OF YOUR SCRIPT ---

/**
 * A robust, universal function to copy text to the clipboard.
 * Tries the modern async clipboard API first, then falls back to the
 * legacy document.execCommand method for broad compatibility.
 * @param {string} textToCopy The text string to be copied.
 * @returns {Promise<void>} A promise that resolves on success or rejects on failure.
 */
function copyTextToClipboard(textToCopy) {
    // Try the modern, secure Clipboard API first
    if (navigator.clipboard && window.isSecureContext) {
        return navigator.clipboard.writeText(textToCopy);
    }
    // If the modern API isn't available, fall back to the legacy method
    else {
        return new Promise((resolve, reject) => {
            // Create a temporary textarea element
            const textArea = document.createElement('textarea');
            textArea.value = textToCopy;

            // Make the textarea invisible and prevent scrolling
            textArea.style.position = 'absolute';
            textArea.style.left = '-9999px';
            textArea.setAttribute('readonly', ''); // Prevents mobile keyboard from popping up

            document.body.appendChild(textArea);

            // Select the text and copy it
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    resolve(); // Resolve the promise on success
                } else {
                    reject(new Error('Copy command failed.')); // Reject on failure
                }
            } catch (err) {
                reject(err); // Reject on error
            } finally {
                // Clean up by removing the temporary element
                document.body.removeChild(textArea);
            }
        });
    }
}

// --- ADD THIS ENTIRE NEW BLOCK OF CODE AT THE END OF YOUR SCRIPT ---

// --- PFP Viewer Logic ---
const pfpViewerModal = document.getElementById('pfp-viewer-modal');
const pfpViewerImage = document.getElementById('pfp-viewer-image');
const pfpViewerContent = document.getElementById('pfp-viewer-content');

// State variables to manage zoom and pan
let scale = 1;
let isPanning = false;
let startPoint = { x: 0, y: 0 };
let endPoint = { x: 0, y: 0 };

function openPfpViewer(imageUrl) {
    if (!imageUrl) return; // Don't open if there's no picture
    
    // Reset state every time the viewer is opened
    scale = 1;
    isPanning = false;
    startPoint = { x: 0, y: 0 };
    endPoint = { x: 0, y: 0 };
    
    pfpViewerImage.src = imageUrl;
    pfpViewerImage.style.transform = 'scale(1) translate(0px, 0px)'; // Reset transform
    pfpViewerModal.style.display = 'flex';
}

function closePfpViewer() {
    pfpViewerModal.style.display = 'none';
    pfpViewerImage.src = ''; // Clear the image source
}

// Event Listeners for the PFP Viewer
document.getElementById('close-pfp-viewer').addEventListener('click', closePfpViewer);

// Zoom with Mouse Wheel
pfpViewerContent.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.1 : 0.1; // Zoom out on scroll down, in on scroll up
    scale = Math.min(Math.max(1, scale + delta), 5); // Clamp scale between 1x and 5x
    pfpViewerImage.style.transform = `scale(${scale}) translate(${endPoint.x}px, ${endPoint.y}px)`;
});

// Pan with Mouse Drag
pfpViewerImage.addEventListener('mousedown', (e) => {
    e.preventDefault();
    isPanning = true;
    pfpViewerImage.classList.add('panning');
    startPoint = { x: e.clientX - endPoint.x, y: e.clientY - endPoint.y };
});

window.addEventListener('mouseup', (e) => {
    isPanning = false;
    pfpViewerImage.classList.remove('panning');
});

window.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    e.preventDefault();
    endPoint = {
        x: e.clientX - startPoint.x,
        y: e.clientY - startPoint.y
    };
    pfpViewerImage.style.transform = `scale(${scale}) translate(${endPoint.x}px, ${endPoint.y}px)`;
});
// --- End of PFP Viewer Logic ---

// --- ADD THIS ENTIRE NEW FUNCTION AT THE END OF YOUR SCRIPT ---

/**
 * A master back-button handler that safely resets the app state to the main chats overview.
 */
function handleSystemBackButton() {
    console.log("System back button triggered. Forcing return to main chats view.");

    // Priority 1: End any active call. This is the most disruptive state.
    if (currentCallData) {
        endCall(); // This function already handles all necessary cleanup and returns the view.
        return; // Let endCall handle the rest.
    }

    // Priority 2: Close any open modals.
    // We check them one by one.
    if (document.getElementById('profile-view-modal').style.display === 'flex') {
        showModal('profile-view-modal', false);
    }
    if (document.getElementById('add-friend-modal').style.display === 'flex') {
        showModal('add-friend-modal', false);
    }
    if (document.getElementById('pfp-viewer-modal').style.display === 'flex') {
        closePfpViewer();
    }
    if (document.getElementById('incoming-call-modal').style.display === 'flex') {
        // Simulate a reject click to properly handle ringtones and state.
        document.getElementById('reject-call-btn').click();
    }

    // Priority 3: Close the search header if it's open.
    if (document.getElementById('search-header').style.display !== 'none') {
        // Simulate a click on the close button to run its logic.
        document.getElementById('close-search-btn').click();
    }

    // Final Action: Ensure we are on the main view and the chats panel is active.
    showView('main-view');
    showPanel('home-content');
}
    </script>


<div id="pfp-viewer-modal" class="pfp-viewer">
    <button id="close-pfp-viewer" class="icon-btn">
        <svg fill="white" viewBox="0 0 24 24" width="32" height="32">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
        </svg>
    </button>
    <div id="pfp-viewer-content">
        <img id="pfp-viewer-image" src="" alt="Profile Picture">
    </div>
    </div>
</body>
</html>